{"meta":{"title":"你过来啊！","subtitle":"性感Android开发，在线挨打","description":"每过段时间，就要踌躇满志一波，但是只能硬三分钟。","author":"Xuqm","url":"https://xuqm.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-04-02T09:55:00.649Z","updated":"2020-04-02T07:25:54.074Z","comments":false,"path":"categories/index.html","permalink":"https://xuqm.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-04-02T09:54:41.258Z","updated":"2020-04-02T07:25:54.073Z","comments":false,"path":"about/index.html","permalink":"https://xuqm.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"Repositories","date":"2020-04-02T08:35:47.091Z","updated":"2020-04-02T07:25:54.074Z","comments":false,"path":"repository/index.html","permalink":"https://xuqm.github.io/repository/index.html","excerpt":"","text":""},{"title":"archives","date":"2020-04-02T07:37:15.000Z","updated":"2020-04-02T09:35:55.453Z","comments":false,"path":"archives/index.html","permalink":"https://xuqm.github.io/archives/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-04-02T09:55:07.904Z","updated":"2020-04-02T07:25:54.074Z","comments":true,"path":"links/index.html","permalink":"https://xuqm.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-02T09:55:27.032Z","updated":"2020-04-02T07:25:54.074Z","comments":false,"path":"tags/index.html","permalink":"https://xuqm.github.io/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2020-04-02T09:54:20.283Z","updated":"2020-04-02T07:25:54.073Z","comments":false,"path":"/404.html","permalink":"https://xuqm.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2020-04-02T09:54:55.864Z","updated":"2020-04-02T07:25:54.073Z","comments":false,"path":"books/index.html","permalink":"https://xuqm.github.io/books/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式-建造者模式","slug":"建造者模式","date":"2020-04-03T05:46:57.000Z","updated":"2020-04-03T05:47:33.592Z","comments":true,"path":"2020/04/03/建造者模式/","link":"","permalink":"https://xuqm.github.io/2020/04/03/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xuqm.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"android","slug":"android","permalink":"https://xuqm.github.io/tags/android/"},{"name":"java","slug":"java","permalink":"https://xuqm.github.io/tags/java/"}]},{"title":"设计模式-抽象工厂模式","slug":"设计模式-抽象工厂模式","date":"2020-04-03T05:32:01.000Z","updated":"2020-04-03T06:39:52.195Z","comments":true,"path":"2020/04/03/设计模式-抽象工厂模式/","link":"","permalink":"https://xuqm.github.io/2020/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"最近在学习设计模式，之前断断续续的看过好多，自己也没有专门的练习和深入了解过，一直感觉对应设计模式相关的东西还是处于懵懂状态，这次下定决心好好的学习一下，所以做一个笔记用来督促自己。 资料收集与以下网站，如有冒犯，烦请告知https://www.runoob.com/design-pattern/design-pattern-tutorial.htmlhttps://www.cnblogs.com/XiOrang/p/9410851.html 简单说明抽象工厂模式，主要是围绕着一个超级工厂创建其它工厂的模式。这个设计模式，将产品归类为多个产品族，每个单品族单独管理产品。抽象工厂模式有多个产品。编不下去了！！！我承认我就是个菜狗 简单理解需要定义多个产品接口，包含各产品的共通的东西。各产品实现上面的接口定义工厂类用于生产定义超级工厂类，用于管理上面的小工厂之前工厂模式的时候，用了一个coder的例子。这里我把coder的技能单独比做产品来使用，不是很合适，勉强看一下吧。 1.定义产品接口1234//可能会的技能public class Coding&#123; void run();&#125;1234//必会的技能public class WriteBugs&#123; void run();&#125; 2.实现产品接口123456public class AndroidCoding implements Coding&#123; @Override public void run()&#123; System.out.pringln(\"Android程序员写了一段代码\"); &#125;&#125;123456public class IosCoding implements Coding&#123; @Override public void run()&#123; System.out.pringln(\"Ios程序员没写代码\"); &#125;&#125;123456public class AndroidBugs implements WriteBugs&#123; @Override public void run()&#123; System.out.pringln(\"Android程序员说没有bug的日子好寂寞啊！！！\"); &#125;&#125;123456public class IosBugs implements WriteBugs&#123; @Override public void run()&#123; System.out.pringln(\"Ios程序员说这些bug哪来的啊！！！\"); &#125;&#125; 3.创建超级工厂抽象类1234public abstract class AbstractFactory&#123; public abstract Coding getCoding(); public abstract WriteBugs getBugs();&#125; 4.创建小工厂，扩展超级工厂12345678910public class AndroidFactory extends AbstractFactory&#123; @Override public Coding getCoding()&#123; return new AndroidCoding(); &#125; @Override public WriteBugs getBugs()&#123; return new AndroidBugs(); &#125;&#125;12345678910public class IosFactory extends AbstractFactory&#123; @Override public Coding getCoding()&#123; return new IosCoding(); &#125; @Override public WriteBugs getBugs()&#123; return new IosBugs(); &#125;&#125; 5.创建一个工厂生成器12345678910public class FactoryProducer&#123; public static AbstractFactory getFactory(String type)&#123; if(\"ANDROID\".equalsIgnoreCase(type))&#123; return new AndroidFactory(); &#125;else if(\"IOS\".equalsIgnoreCase(type))&#123; return new IosFactory(); &#125; return null; &#125;&#125; 6.使用过程12345678910111213141516public class Test&#123; public static void main(Strign[] args)&#123; AbstractFactory android = FactoryProducer.getFactory(\"Android\"); Coding androidCoding = android.getCoding(); WriteBugs androidBugs = android.getBugs(); androidCoding.run(); androidBugs.run(); AbstractFactory ios = FactoryProducer.getFactory(\"IOS\"); Coding iosCoding = ios.getCoding(); WriteBugs iosBugs = ios.getBugs(); iosCoding.run(); iosBugs.run(); &#125;&#125;感觉菜鸟教程的抽象工厂模式有点问题，不知道是不是我的理解有错误。个人觉得抽象工厂里面的小工厂应该是包含多个不同类型产品的工厂菜鸟的教程是包含多个同一类型的产品","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xuqm.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"android","slug":"android","permalink":"https://xuqm.github.io/tags/android/"},{"name":"java","slug":"java","permalink":"https://xuqm.github.io/tags/java/"}]},{"title":"设计模式-工厂模式","slug":"设计模式-工厂模式","date":"2020-04-03T03:38:24.000Z","updated":"2020-04-03T04:05:14.717Z","comments":true,"path":"2020/04/03/设计模式-工厂模式/","link":"","permalink":"https://xuqm.github.io/2020/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"最近在学习设计模式，之前断断续续的看过好多，自己也没有专门的练习和深入了解过，一直感觉对应设计模式相关的东西还是处于懵懂状态，这次下定决心好好的学习一下，所以做一个笔记用来督促自己。 资料收集与以下网站，如有冒犯，烦请告知https://www.runoob.com/design-pattern/design-pattern-tutorial.html 简单说明工厂模式属于创建型设计模式的一种。使用这个模式，我们不需要知道实例是怎么创建的，完全由工厂根据我们的需求来搞。每次增加新实例的时候，都需要添加一个具体类和实现工厂，增加了系统的复杂度，同时也增加了系统具体类的依赖。编不下去了！！！我承认我就是个菜狗 简单理解需要定义一个接口，包含各产品的共通的东西。各产品实现上面的接口定义工厂类用于生产我需要一个小伙伴陪我一起coding，奈何现实不理我，没办法，自己生产一个？？？ 1.定义一个接口1234public interface Coder&#123; //会coding就够了，还要啥自行车 void coding();&#125; 2.来一个Android的coder吧123456public class Android implements Coder&#123; @Override public void coding()&#123; System.out.println(\"Android开发，在线接客！\") &#125;&#125; 3.其实IOS开发也是可以的123456public class Ios implements Coder&#123; @Override public void coding()&#123; System.out.println(\"没有bug的日子，好寂寞！！！\") &#125;&#125; 4.需要一个学校？培训机构来生产他们啊(Factory)123456789101112public class CoderFactory&#123; public Coder getCoder(String type)&#123; if(null == type) return null; if(\"ANDROID\".equalsIgnoreCase(type))&#123; return new Android(); &#125;else if(\"IOS\".equalsIgnoreCase(type))&#123; return new Ios(); &#125; return null; &#125;&#125; 5.神说要有光~~~123456789public class TestCoder&#123; public static void main(String[] args)&#123; CoderFactory factory = new CoderFactory(); Android android = factory.getCoder(\"Android\"); Ios ios = factory.getCoder(\"IOS\"); android.coding(); ios.coding(); &#125;&#125;梦醒了，除了嘴角有点湿，啥也没搞到。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xuqm.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"android","slug":"android","permalink":"https://xuqm.github.io/tags/android/"},{"name":"java","slug":"java","permalink":"https://xuqm.github.io/tags/java/"}]},{"title":"设计模式-单例模式","slug":"设计模式-单例模式","date":"2020-04-03T02:12:48.000Z","updated":"2020-04-03T03:27:30.163Z","comments":true,"path":"2020/04/03/设计模式-单例模式/","link":"","permalink":"https://xuqm.github.io/2020/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"最近在学习设计模式，之前断断续续的看过好多，自己也没有专门的练习和深入了解过，一直感觉对应设计模式相关的东西还是处于懵懂状态，这次下定决心好好的学习一下，所以做一个笔记用来督促自己。 资料收集与以下网站，如有冒犯，烦请告知https://www.cnblogs.com/garryfu/p/7976546.htmlhttp://c.biancheng.net/design_pattern/https://www.runoob.com/design-pattern/design-pattern-tutorial.html 简单说明单例模式可以维持系统内某个类只有一个实例。在系统中，日志对象、对话框、打印机驱动等通常的会设计成单例模式。单例模式主要用来保持状态的统一，避免不同请求同时调用时，会造成状态混乱的情况。编不下去了！！！我承认我就是个菜狗 简单理解类的构造器私有化内部实例化外部全局访问 静态常量实现 饿汉式123456789101112131415161718192021public class Singleton &#123; //私有化构造函数 private Singleton() &#123; &#125; //静态常量 private static final Singleton instance = new Singleton(); //外部访问接口 public static Singleton getInstance() &#123; return instance; &#125; //提供一个外部访问方法，用来测试 public void print() &#123; System.out.println(\"创建成功\"); &#125;&#125;class a &#123; public static void main(String[] args) &#123; Singleton.getInstance().print();//测试 &#125;&#125; 静态代码块实现 - 饿汉式12345678910111213141516public class Singleton&#123; //私有化构造函数 private Singletonton()&#123; &#125; //静态代码块实现 private static Singleton instance; static&#123; instance = new Singleton(); &#125; //提供一个外部访问的方法 public static Singleton getInstance()&#123; return instance; &#125; &#125; 模式特点饿汉式单例，在类加载的时候就已经创建好了一个静态对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程 线程不安全的 - 懒汉式1234567891011public class Singleton&#123; private static Singleton instance; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; if(null == instance) instance = new Singleton(); return instance; &#125;&#125; 线程安全的 - 懒汉式1234567891011public class Singleton&#123; private static Singleton instance; private Singleton()&#123; &#125; public static synchronized Singleton getInstance()&#123; if(null == instance) instance = new Singleton(); return instance; &#125;&#125; 模式特点懒汉式单例模式，使用了延迟加载的方式，只有在调用getInstance()方法时才会进行实例化第一种模式虽然可以做到延时加载，但是在多线程的使用场景中容易出现多实例的情况第二种模式添加了synchronized同步锁，使得该方法变成了线程安全的方式，但是多数情况下是不需要同步的，所以该模式运行效率很低。 双重校验锁模式1234567891011121314151617public class Singleton &#123; private Singleton()&#123; &#125; private static Singleton instance; public static Singleton getInstance()&#123; if(null == instance)&#123; synchronized(Singleton.class)&#123; if(null == instance)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; &#125; 模式特点延迟加载第一次判断instance为空的时候，会进入同步锁，进入同步锁的线程根据再次判断的情况，实例化Singleton,第二次访问的时候，instance不为空，则不进入同步锁，保证了执行效率。 静态内部类模式1234567891011public class Singleton&#123; private Singleton()&#123; &#125; private static class SingletonHolder&#123; private static Singleton instance = new Singleton(); &#125; public static Singleton getInstance()&#123; return SingletonHolder.instance; &#125;&#125; 模式特点多线程并发下，线程是安全的但是遇到序列号对象时，默认的方式运行得到的结果就是多例的。 枚举模式12345678910111213public enum Singleton&#123; INSTANCE; private String test = \"singleton\"; public void print()&#123; System.out.println(a); &#125;&#125;//测试一下public test&#123; public static void main(String[] args)&#123; Singleton.INSTANCE.print(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xuqm.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"android","slug":"android","permalink":"https://xuqm.github.io/tags/android/"},{"name":"java","slug":"java","permalink":"https://xuqm.github.io/tags/java/"}]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xuqm.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"android","slug":"android","permalink":"https://xuqm.github.io/tags/android/"},{"name":"java","slug":"java","permalink":"https://xuqm.github.io/tags/java/"}]}