{"meta":{"title":"你过来啊！","subtitle":"性感Android开发，在线挨打","description":"每过段时间，就要踌躇满志一波，但是只能硬三分钟。","author":"Xuqm","url":"https://xuqm.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-04-03T05:45:22.667Z","updated":"2020-04-02T07:25:54.073Z","comments":false,"path":"/404.html","permalink":"https://xuqm.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-04-03T07:01:53.749Z","updated":"2020-04-03T07:01:53.749Z","comments":false,"path":"about/index.html","permalink":"https://xuqm.github.io/about/index.html","excerpt":"","text":"这是一条咸鱼，啥也不会，啥也不懂。"},{"title":"书单","date":"2020-04-02T09:54:55.864Z","updated":"2020-04-02T07:25:54.073Z","comments":false,"path":"books/index.html","permalink":"https://xuqm.github.io/books/index.html","excerpt":"","text":""},{"title":"archives","date":"2020-04-02T07:37:15.000Z","updated":"2020-04-02T09:35:55.453Z","comments":false,"path":"archives/index.html","permalink":"https://xuqm.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-04-02T09:55:00.649Z","updated":"2020-04-02T07:25:54.074Z","comments":false,"path":"categories/index.html","permalink":"https://xuqm.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-04-02T09:55:07.904Z","updated":"2020-04-02T07:25:54.074Z","comments":true,"path":"links/index.html","permalink":"https://xuqm.github.io/links/index.html","excerpt":"","text":""},{"title":"我的项目","date":"2020-04-03T06:59:54.245Z","updated":"2020-04-03T06:59:54.245Z","comments":false,"path":"repository/index.html","permalink":"https://xuqm.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-02T09:55:27.032Z","updated":"2020-04-02T07:25:54.074Z","comments":false,"path":"tags/index.html","permalink":"https://xuqm.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用Django 做服务端开发的一次尝试-3","slug":"django 做服务端的练习-003","date":"2020-04-20T03:30:01.000Z","updated":"2020-04-20T03:30:46.483Z","comments":true,"path":"2020/04/20/django 做服务端的练习-003/","link":"","permalink":"https://xuqm.github.io/2020/04/20/django%20%E5%81%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E7%BB%83%E4%B9%A0-003/","excerpt":"","text":"","categories":[{"name":"python","slug":"python","permalink":"https://xuqm.github.io/categories/python/"},{"name":"django","slug":"python/django","permalink":"https://xuqm.github.io/categories/python/django/"}],"tags":[{"name":"python","slug":"python","permalink":"https://xuqm.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://xuqm.github.io/tags/django/"},{"name":"restframework","slug":"restframework","permalink":"https://xuqm.github.io/tags/restframework/"}]},{"title":"使用Django 做服务端开发的一次尝试-2","slug":"django 做服务端的练习-002","date":"2020-04-17T10:06:46.000Z","updated":"2020-05-18T06:18:05.705Z","comments":true,"path":"2020/04/17/django 做服务端的练习-002/","link":"","permalink":"https://xuqm.github.io/2020/04/17/django%20%E5%81%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E7%BB%83%E4%B9%A0-002/","excerpt":"","text":"之前完成了一个django项目的新建工作，这次就做一些初始化的东西吧 1.使用postgresql数据库数据库用户、密码、库 这些东西，先准备好使用 pip install psycopg2 命令安装 psycopg2 作为数据库驱动，可能会遇到问题，我是直接安装了个vs2019 解决的，粗暴而简单修改settings.py文件(自己本地玩的，用户名密码就不隐藏了)123456789101112DATABASES = &#123; 'default': &#123; # 'ENGINE': 'django.db.backends.sqlite3', # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'django-rest', # 数据库名字 'USER': 'django', # 用户名 \"PASSWORD\": '123456', # 自己的密码 \"HOST\": '127.0.0.1', 'PORT': 5432, &#125;&#125;直接迁移数据库：python manage.py migrate数据库迁移完成，我习惯直接开启admin，python manage.py createsuperuser1234567891011121314(venv) E:\\PythonProjects\\djanfo_rest&gt;python manage.py createsuperuserUsername (leave blank to use 'xuqin'): xuqmError: That username is already taken.Username (leave blank to use 'xuqin'): adminEmail address: 123456Error: Enter a valid email address.Email address: xuqinmin12@sina.comPassword:Password (again):This password is too short. It must contain at least 8 characters.This password is too common.This password is entirely numeric.Bypass password validation and create user anyway? [y/N]: ySuperuser created successfully.使用的是一个旧的数据库，所以其实已经创建过超级用户了理论上现在可以看到管理页面了，http://127.0.0.1:8000/admin输入刚才创建的超级用户的用户名密码，完成登录就是长的这样子。现有有个问题，我这个学渣，看不懂英文。改！修改settings.py文件123LANGUAGE_CODE = 'zh-Hans'TIME_ZONE = 'Asia/Harbin'结果就好看多了么下班了~","categories":[{"name":"python","slug":"python","permalink":"https://xuqm.github.io/categories/python/"},{"name":"django","slug":"python/django","permalink":"https://xuqm.github.io/categories/python/django/"}],"tags":[{"name":"python","slug":"python","permalink":"https://xuqm.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://xuqm.github.io/tags/django/"},{"name":"restframework","slug":"restframework","permalink":"https://xuqm.github.io/tags/restframework/"}]},{"title":"使用Django 做服务端开发的一次尝试-1","slug":"django 做服务端的练习","date":"2020-04-17T06:38:24.000Z","updated":"2020-05-18T06:17:41.343Z","comments":true,"path":"2020/04/17/django 做服务端的练习/","link":"","permalink":"https://xuqm.github.io/2020/04/17/django%20%E5%81%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E7%BB%83%E4%B9%A0/","excerpt":"","text":"最近在学习设计模式，之前断断续续的看过好多，自己也没有专门的练习和深入了解过，一直感觉对应设计模式相关的东西还是处于懵懂状态，这次下定决心好好的学习一下，所以做一个笔记用来督促自己。前段时间，想要整理一下现有的Android技术，写一个可以用的快速开发框架，然而，咸鱼依然还是咸鱼。使用mvvm模式，写了一部分。不会放出来的，那么羞耻的东西。重点是，想要调用接口做测试的时候，突然想起来当年玩过几天Django，接着就想，是不是可以用django写一个测试用的服务呢？写一个试试吧。 走一步看一步吧，走到哪是哪才是咸鱼的本命 1.新建一个项目，这里我用的是 PyCharm做的开发。写到这里，突然想起来需要截图，然后想了下图片需要上传到服务器，然后想要了解下有哪些可以用的服务器，等我回来。想了想，自己有个闲置的阿里云服务器，就用它吧写了个脚本，使用 python -m SimpleHTTPServer 启动一个文件服务我的项目都是这么创建的，感觉比较方便环境用的是anaconda 的python3.7，我本地的是3.8版本，直接使用的时候，配置postgresql的时候会出问题，没找到为啥，换了一个就好了等了一会，该转的圈转完了，新建项目的工作完成了。目录结构启动一下看看效果,看看开心的小火箭。","categories":[{"name":"python","slug":"python","permalink":"https://xuqm.github.io/categories/python/"},{"name":"django","slug":"python/django","permalink":"https://xuqm.github.io/categories/python/django/"}],"tags":[{"name":"python","slug":"python","permalink":"https://xuqm.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://xuqm.github.io/tags/django/"},{"name":"restframework","slug":"restframework","permalink":"https://xuqm.github.io/tags/restframework/"}]},{"title":"设计模式-建造者模式","slug":"设计模式-建造者模式","date":"2020-04-03T05:46:57.000Z","updated":"2020-04-03T05:47:33.592Z","comments":true,"path":"2020/04/03/设计模式-建造者模式/","link":"","permalink":"https://xuqm.github.io/2020/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xuqm.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"android","slug":"android","permalink":"https://xuqm.github.io/tags/android/"},{"name":"java","slug":"java","permalink":"https://xuqm.github.io/tags/java/"}]},{"title":"设计模式-抽象工厂模式","slug":"设计模式-抽象工厂模式","date":"2020-04-03T05:32:01.000Z","updated":"2020-04-03T06:43:10.158Z","comments":true,"path":"2020/04/03/设计模式-抽象工厂模式/","link":"","permalink":"https://xuqm.github.io/2020/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"最近在学习设计模式，之前断断续续的看过好多，自己也没有专门的练习和深入了解过，一直感觉对应设计模式相关的东西还是处于懵懂状态，这次下定决心好好的学习一下，所以做一个笔记用来督促自己。 资料收集与以下网站，如有冒犯，烦请告知https://www.runoob.com/design-pattern/design-pattern-tutorial.htmlhttps://www.cnblogs.com/XiOrang/p/9410851.html 简单说明抽象工厂模式，主要是围绕着一个超级工厂创建其它工厂的模式。这个设计模式，将产品归类为多个产品族，每个单品族单独管理产品。抽象工厂模式有多个产品。编不下去了！！！我承认我就是个菜狗 简单理解需要定义多个产品接口，包含各产品的共通的东西。各产品实现上面的接口定义工厂类用于生产定义超级工厂类，用于管理上面的小工厂之前工厂模式的时候，用了一个coder的例子。这里我把coder的技能单独比做产品来使用，不是很合适，勉强看一下吧。 1.定义产品接口1234//可能会的技能public class Coding&#123; void run();&#125;1234//必会的技能public class WriteBugs&#123; void run();&#125; 2.实现产品接口123456public class AndroidCoding implements Coding&#123; @Override public void run()&#123; System.out.pringln(\"Android程序员写了一段代码\"); &#125;&#125;123456public class IosCoding implements Coding&#123; @Override public void run()&#123; System.out.pringln(\"Ios程序员没写代码\"); &#125;&#125;123456public class AndroidBugs implements WriteBugs&#123; @Override public void run()&#123; System.out.pringln(\"Android程序员说没有bug的日子好寂寞啊！！！\"); &#125;&#125;123456public class IosBugs implements WriteBugs&#123; @Override public void run()&#123; System.out.pringln(\"Ios程序员说这些bug哪来的啊！！！\"); &#125;&#125; 3.创建超级工厂抽象类1234public abstract class AbstractFactory&#123; public abstract Coding getCoding(); public abstract WriteBugs getBugs();&#125; 4.创建小工厂，扩展超级工厂12345678910public class AndroidFactory extends AbstractFactory&#123; @Override public Coding getCoding()&#123; return new AndroidCoding(); &#125; @Override public WriteBugs getBugs()&#123; return new AndroidBugs(); &#125;&#125;12345678910public class IosFactory extends AbstractFactory&#123; @Override public Coding getCoding()&#123; return new IosCoding(); &#125; @Override public WriteBugs getBugs()&#123; return new IosBugs(); &#125;&#125; 5.创建一个工厂生成器12345678910public class FactoryProducer&#123; public static AbstractFactory getFactory(String type)&#123; if(\"ANDROID\".equalsIgnoreCase(type))&#123; return new AndroidFactory(); &#125;else if(\"IOS\".equalsIgnoreCase(type))&#123; return new IosFactory(); &#125; return null; &#125;&#125; 6.使用过程12345678910111213141516public class Test&#123; public static void main(Strign[] args)&#123; AbstractFactory android = FactoryProducer.getFactory(\"Android\"); Coding androidCoding = android.getCoding(); WriteBugs androidBugs = android.getBugs(); androidCoding.run(); androidBugs.run(); AbstractFactory ios = FactoryProducer.getFactory(\"IOS\"); Coding iosCoding = ios.getCoding(); WriteBugs iosBugs = ios.getBugs(); iosCoding.run(); iosBugs.run(); &#125;&#125;感觉菜鸟教程的抽象工厂模式有点问题，不知道是不是我的理解有错误。个人觉得抽象工厂里面的小工厂应该是包含多个不同类型产品的工厂菜鸟的教程是包含多个同一类型的产品","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xuqm.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"android","slug":"android","permalink":"https://xuqm.github.io/tags/android/"},{"name":"java","slug":"java","permalink":"https://xuqm.github.io/tags/java/"}]},{"title":"设计模式-工厂模式","slug":"设计模式-工厂模式","date":"2020-04-03T03:38:24.000Z","updated":"2020-04-03T04:05:14.717Z","comments":true,"path":"2020/04/03/设计模式-工厂模式/","link":"","permalink":"https://xuqm.github.io/2020/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"最近在学习设计模式，之前断断续续的看过好多，自己也没有专门的练习和深入了解过，一直感觉对应设计模式相关的东西还是处于懵懂状态，这次下定决心好好的学习一下，所以做一个笔记用来督促自己。 资料收集与以下网站，如有冒犯，烦请告知https://www.runoob.com/design-pattern/design-pattern-tutorial.html 简单说明工厂模式属于创建型设计模式的一种。使用这个模式，我们不需要知道实例是怎么创建的，完全由工厂根据我们的需求来搞。每次增加新实例的时候，都需要添加一个具体类和实现工厂，增加了系统的复杂度，同时也增加了系统具体类的依赖。编不下去了！！！我承认我就是个菜狗 简单理解需要定义一个接口，包含各产品的共通的东西。各产品实现上面的接口定义工厂类用于生产我需要一个小伙伴陪我一起coding，奈何现实不理我，没办法，自己生产一个？？？ 1.定义一个接口1234public interface Coder&#123; //会coding就够了，还要啥自行车 void coding();&#125; 2.来一个Android的coder吧123456public class Android implements Coder&#123; @Override public void coding()&#123; System.out.println(\"Android开发，在线接客！\") &#125;&#125; 3.其实IOS开发也是可以的123456public class Ios implements Coder&#123; @Override public void coding()&#123; System.out.println(\"没有bug的日子，好寂寞！！！\") &#125;&#125; 4.需要一个学校？培训机构来生产他们啊(Factory)123456789101112public class CoderFactory&#123; public Coder getCoder(String type)&#123; if(null == type) return null; if(\"ANDROID\".equalsIgnoreCase(type))&#123; return new Android(); &#125;else if(\"IOS\".equalsIgnoreCase(type))&#123; return new Ios(); &#125; return null; &#125;&#125; 5.神说要有光~~~123456789public class TestCoder&#123; public static void main(String[] args)&#123; CoderFactory factory = new CoderFactory(); Android android = factory.getCoder(\"Android\"); Ios ios = factory.getCoder(\"IOS\"); android.coding(); ios.coding(); &#125;&#125;梦醒了，除了嘴角有点湿，啥也没搞到。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xuqm.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"android","slug":"android","permalink":"https://xuqm.github.io/tags/android/"},{"name":"java","slug":"java","permalink":"https://xuqm.github.io/tags/java/"}]},{"title":"设计模式-单例模式","slug":"设计模式-单例模式","date":"2020-04-03T02:12:48.000Z","updated":"2020-04-03T03:27:30.163Z","comments":true,"path":"2020/04/03/设计模式-单例模式/","link":"","permalink":"https://xuqm.github.io/2020/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"最近在学习设计模式，之前断断续续的看过好多，自己也没有专门的练习和深入了解过，一直感觉对应设计模式相关的东西还是处于懵懂状态，这次下定决心好好的学习一下，所以做一个笔记用来督促自己。 资料收集与以下网站，如有冒犯，烦请告知https://www.cnblogs.com/garryfu/p/7976546.htmlhttp://c.biancheng.net/design_pattern/https://www.runoob.com/design-pattern/design-pattern-tutorial.html 简单说明单例模式可以维持系统内某个类只有一个实例。在系统中，日志对象、对话框、打印机驱动等通常的会设计成单例模式。单例模式主要用来保持状态的统一，避免不同请求同时调用时，会造成状态混乱的情况。编不下去了！！！我承认我就是个菜狗 简单理解类的构造器私有化内部实例化外部全局访问 静态常量实现 饿汉式123456789101112131415161718192021public class Singleton &#123; //私有化构造函数 private Singleton() &#123; &#125; //静态常量 private static final Singleton instance = new Singleton(); //外部访问接口 public static Singleton getInstance() &#123; return instance; &#125; //提供一个外部访问方法，用来测试 public void print() &#123; System.out.println(\"创建成功\"); &#125;&#125;class a &#123; public static void main(String[] args) &#123; Singleton.getInstance().print();//测试 &#125;&#125; 静态代码块实现 - 饿汉式12345678910111213141516public class Singleton&#123; //私有化构造函数 private Singletonton()&#123; &#125; //静态代码块实现 private static Singleton instance; static&#123; instance = new Singleton(); &#125; //提供一个外部访问的方法 public static Singleton getInstance()&#123; return instance; &#125; &#125; 模式特点饿汉式单例，在类加载的时候就已经创建好了一个静态对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程 线程不安全的 - 懒汉式1234567891011public class Singleton&#123; private static Singleton instance; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; if(null == instance) instance = new Singleton(); return instance; &#125;&#125; 线程安全的 - 懒汉式1234567891011public class Singleton&#123; private static Singleton instance; private Singleton()&#123; &#125; public static synchronized Singleton getInstance()&#123; if(null == instance) instance = new Singleton(); return instance; &#125;&#125; 模式特点懒汉式单例模式，使用了延迟加载的方式，只有在调用getInstance()方法时才会进行实例化第一种模式虽然可以做到延时加载，但是在多线程的使用场景中容易出现多实例的情况第二种模式添加了synchronized同步锁，使得该方法变成了线程安全的方式，但是多数情况下是不需要同步的，所以该模式运行效率很低。 双重校验锁模式1234567891011121314151617public class Singleton &#123; private Singleton()&#123; &#125; private static Singleton instance; public static Singleton getInstance()&#123; if(null == instance)&#123; synchronized(Singleton.class)&#123; if(null == instance)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; &#125; 模式特点延迟加载第一次判断instance为空的时候，会进入同步锁，进入同步锁的线程根据再次判断的情况，实例化Singleton,第二次访问的时候，instance不为空，则不进入同步锁，保证了执行效率。 静态内部类模式1234567891011public class Singleton&#123; private Singleton()&#123; &#125; private static class SingletonHolder&#123; private static Singleton instance = new Singleton(); &#125; public static Singleton getInstance()&#123; return SingletonHolder.instance; &#125;&#125; 模式特点多线程并发下，线程是安全的但是遇到序列号对象时，默认的方式运行得到的结果就是多例的。 枚举模式12345678910111213public enum Singleton&#123; INSTANCE; private String test = \"singleton\"; public void print()&#123; System.out.println(a); &#125;&#125;//测试一下public test&#123; public static void main(String[] args)&#123; Singleton.INSTANCE.print(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xuqm.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"android","slug":"android","permalink":"https://xuqm.github.io/tags/android/"},{"name":"java","slug":"java","permalink":"https://xuqm.github.io/tags/java/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://xuqm.github.io/categories/python/"},{"name":"django","slug":"python/django","permalink":"https://xuqm.github.io/categories/python/django/"},{"name":"设计模式","slug":"设计模式","permalink":"https://xuqm.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"python","slug":"python","permalink":"https://xuqm.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://xuqm.github.io/tags/django/"},{"name":"restframework","slug":"restframework","permalink":"https://xuqm.github.io/tags/restframework/"},{"name":"android","slug":"android","permalink":"https://xuqm.github.io/tags/android/"},{"name":"java","slug":"java","permalink":"https://xuqm.github.io/tags/java/"}]}