{"meta":{"title":"你过来啊！","subtitle":"性感Android开发，在线挨打","description":"每过段时间，就要踌躇满志一波，但是只能硬三分钟。","author":"Xuqm","url":"https://blog.xuqinmin.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-04-03T05:45:22.667Z","updated":"2020-04-02T07:25:54.073Z","comments":false,"path":"/404.html","permalink":"https://blog.xuqinmin.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-05-18T07:46:06.147Z","updated":"2020-05-18T07:46:06.147Z","comments":false,"path":"about/index.html","permalink":"https://blog.xuqinmin.com/about/index.html","excerpt":"","text":"这是一条咸鱼，啥也不会，啥也不懂。个人邮箱：xuqinmin12@sina.com"},{"title":"archives","date":"2020-04-02T07:37:15.000Z","updated":"2020-04-02T09:35:55.453Z","comments":false,"path":"archives/index.html","permalink":"https://blog.xuqinmin.com/archives/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-04-02T09:54:55.864Z","updated":"2020-04-02T07:25:54.073Z","comments":false,"path":"books/index.html","permalink":"https://blog.xuqinmin.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-04-02T09:55:00.649Z","updated":"2020-04-02T07:25:54.074Z","comments":false,"path":"categories/index.html","permalink":"https://blog.xuqinmin.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-04-02T09:55:07.904Z","updated":"2020-04-02T07:25:54.074Z","comments":true,"path":"links/index.html","permalink":"https://blog.xuqinmin.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-02T09:55:27.032Z","updated":"2020-04-02T07:25:54.074Z","comments":false,"path":"tags/index.html","permalink":"https://blog.xuqinmin.com/tags/index.html","excerpt":"","text":""},{"title":"我的项目","date":"2020-04-03T06:59:54.245Z","updated":"2020-04-03T06:59:54.245Z","comments":false,"path":"repository/index.html","permalink":"https://blog.xuqinmin.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"CSS选择器学习记录","slug":"CSS选择器","date":"2020-05-21T09:46:57.000Z","updated":"2020-05-21T09:55:34.140Z","comments":true,"path":"2020/05/21/CSS选择器/","link":"","permalink":"https://blog.xuqinmin.com/2020/05/21/CSS%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"","text":"现在各种跨平台框架挺流行的，看了下都要使用js，emm。。。 不会啊，想着学习一下吧，看着看着，觉得，还是把前端过一遍把，找的资料是实验楼提供的资源 资料收集与以下网站，如有冒犯，烦请告知https://www.shiyanlou.com/courses/1237之前写的忘记记录，写到 CSS选择器 部分才想起来。 选择器分类选择器类型选择器内容基础选择器标签选择器、类选择器、id 选择器、 通配符选择器组合选择器标签指定式选择器、后代选择器、并集选择器属性选择器伪类选择器 标签选择器标签选择器也叫元素选择器，其实就是html代码中的标签如：&lt;html&gt; &lt;body&gt; &lt;h1&gt; &lt;p&gt; &lt;img&gt;1234标签名 &#123; 属性1:属性值1; 属性2:属性值2;&#125; 类选择器类选择器是对HTML 标签中 class 属性进行选择。CSS 类选择器的选择符是 “.”类选择器命名规范：不能是纯数字，不能是标签名，不建议使用汉字。一般是 点+对应样式的描述。如：.shadow123.bgc &#123; background-color: yellow; &#125;值得注意的是文档中的多个元素可以具有相同的类名，单个元素可以有多个类名(以空格分开多个类名的形式书写)。 id选择器对HTML 标签属性进行选择。id选择器的选择符是&quot;#&quot;。任何元素都可以使用id属性设置唯一的id名称。这是选择单个元素最有效的方式。特别属性注意的是id选择器具有唯一性，也就是说同一个HTML页面不能有相同的id名称(使用多个相同的id选择器，浏览器不会报错但是不符合W3C标准)1234#id名&#123;属性1:属性值1;属性2:属性值2;&#125; 通配符选择器通配符选择器用*号表示，他是所有选择器中作用范围最广的，能匹配页面中所有的元素。1234* &#123; 属性1:属性值1; 属性2:属性值2;&#125;一般使用通配符选择器定义CSS样式,清楚所有HTML标记的默认边距。1234* &#123; margin: 0; padding: 0;&#125; 标签指定式选择器标签指定式选择器又称交集选择器，有两个选择器构成，其中第一个必须是标签选择器，第二个为class选择器或id选择器。两个选择器之间不能有空格。1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; p &#123; color: red; &#125; p.one &#123; color: blue; &#125; p#two &#123; color: yellow; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;实验楼&lt;/p&gt; &lt;p class=\"one\"&gt;实验楼&lt;/p&gt; &lt;p id=\"two\"&gt;实验楼&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 后代选择器后代选择器又叫包含选择器，用来选择元素或元素组的后代。其写法就是把外层标记写在前面，内层标记写在后面，中间用空格分隔。当标记发生嵌套时，内层标记就成为外层标记的后代。12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; .one #two p &#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"one\"&gt; &lt;div id=\"two\"&gt; &lt;p&gt;实验楼&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 子代选择器与后代选择器相比，子元素选择器只能选择某个元素的子元素。子选择器使用大于号作为子结合符。123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; p &gt; strong &#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;strong&gt;实验楼&lt;/strong&gt; &lt;strong&gt;实验楼&lt;/strong&gt; &lt;/p&gt; &lt;p&gt; &lt;em&gt; &lt;strong&gt;实验楼&lt;/strong&gt; &lt;strong&gt;实验楼&lt;/strong&gt; &lt;/em&gt; &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 并集选择器并集选择器是各个选择器通过逗号连接而成的，任何形式的选择器（包括标签选择器、class 类选择器、id 选择器等），都可以作为并集选择器的一部分。如果某些选择器定义的样式完全相同，或部分相同，就可以利用并集选择器为它们定义相同的 CSS 样式。12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; p, #one, .two &#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;我爱学习&lt;/p&gt; &lt;span id=\"one\"&gt;我爱运动&lt;/span&gt; &lt;strong class=\"two\"&gt;我爱睡觉&lt;/strong&gt; &lt;/body&gt;&lt;/html&gt; 属性选择器属性选择器是根据元素的属性及属性值来选择元素。属性选择器含义示例E[attr]匹配所有具有attr属性的E元素，不考虑它的值。(E指的是元素，也就是标签，attr指的是属性)p[title] {color: red;}E[attr=val]匹配所有attr属性等于&quot;val&quot;的E元素p[title=“one”]{color: yellow;}E[attr~=val]匹配所有属性具有多个空格分隔的值，其中一个值等于&quot;val&quot;的E元素td[class~=“name”]{color: #f00}E[attr |= val]匹配所有attr属性具有多个连字号分割的值、其中一个值以&quot;val&quot;开头的E元素，主要用于 lang属性，比如&quot;en&quot;、 “en-us”、 &quot;en-gb&quot;等等p[lang |= en ]{color: blue;} 伪类选择器CSS 伪类用于向某些选择器添加特殊的效果。1234:link 应用于未被访问过的链接。IE6 不兼容，解决此问题，直接使用 a 标签。:hover 应用于有鼠标指针悬停于其上的元素。在 IE6 只能应用于 a 连接，IE7+ 所有元素都兼容。:active 应用于被激活的元素，如被点击的链接、被按下的按钮等。:visited 应用于已经被访问过的链接123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; /*a:link&#123; color: red; &#125;*/ /*链接默认状态*/ a &#123; color: red; text-decoration: none; &#125; /*链接访问之后的状态*/ a:visited &#123; color: yellow; &#125; /*鼠标放到链接上显示的状态*/ a:hover &#123; color: blue; text-decoration: line-through; &#125; /*链接激活的状态*/ a:active &#123; color: pink; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"\"&gt;实验楼&lt;/a&gt; &lt;/body&gt;&lt;/html&gt;注：我们可能会遇到被点击访问过的超链接不再具有 hover 和 active 了，解决办法是改变 CSS 属性的排列顺序，L-V-H-A（link-visited-hover-active）。您可以运行一下，然后更改 L-V-H-A 的顺序后，看看效果。后面还有 “CSS层叠性和继承性” 还没开始看，脑子有点昏，下次再看了。","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.xuqinmin.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css","slug":"css","permalink":"https://blog.xuqinmin.com/tags/css/"}]},{"title":"设计模式-建造者模式","slug":"设计模式-建造者模式","date":"2020-05-20T07:47:27.000Z","updated":"2020-05-21T02:20:06.627Z","comments":true,"path":"2020/05/20/设计模式-建造者模式/","link":"","permalink":"https://blog.xuqinmin.com/2020/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"最近在学习设计模式，之前断断续续的看过好多，自己也没有专门的练习和深入了解过，一直感觉对应设计模式相关的东西还是处于懵懂状态，这次下定决心好好的学习一下，所以做一个笔记用来督促自己。 资料收集与以下网站，如有冒犯，烦请告知https://www.runoob.com/design-pattern/builder-pattern.html 定义The intent of the Builder design pattern is to separate the construction of a complex object from its representation. By doing so the same construction process can create different representations.将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示 简单说明1.当一个类的构建过于复杂的时候，就可以考虑builder模式了。 上手试一下，还是用coder的例子吧,之前写了个简易的链式模式，这次学习一下传统写法。 1.程序员基类123456789101112131415161718192021222324252627public class Coder &#123; private String name;//名称 private String language;//编程语言 private String coding;//编程能力 private String writeBug;//bug生产力 public void setName(String name) &#123; this.name = name; &#125; public void setLanguage(String language) &#123; this.language = language; &#125; public void setCoding(String coding) &#123; this.coding = coding; &#125; public void setWriteBug(String writeBug) &#123; this.writeBug = writeBug; &#125; public void draw() &#123; System.out.printf(\"%s程序员，使用%s编程语言，%s，%s。\", name, language, coding, writeBug); &#125;&#125; 2. Builder类1234567891011public abstract class Builder &#123; public abstract void setName(); public abstract void setLanguage(); public abstract void setCoding(); public abstract void setWriteBug(); public abstract Coder getCoder();&#125; 3.创建一个Android程序员Builder12345678910111213141516171819202122232425262728public class AndroidBuilder extends Builder &#123; private Coder coder = new Coder(); @Override public void setName() &#123; coder.setName(\"Android\"); &#125; @Override public void setLanguage() &#123; coder.setLanguage(\"Java\"); &#125; @Override public void setCoding() &#123; coder.setCoding(\"写了三行代码\"); &#125; @Override public void setWriteBug() &#123; coder.setWriteBug(\"竟然没有bug\"); &#125; @Override public Coder getCoder() &#123; return coder; &#125;&#125; 4.指导者类123456789public class CoderDirector &#123;//指导者类 public void makeCoder(Builder builder) &#123; builder.setName(); builder.setLanguage(); builder.setCoding(); builder.setWriteBug(); &#125;&#125; 5.使用一下123456789public class Test &#123; public static void main(String[] args) &#123; CoderDirector director = new CoderDirector();//1 AndroidBuilder builder = new AndroidBuilder();//2 director.makeCoder(builder);//3 Coder coder = builder.getCoder();//4 coder.draw(); &#125;&#125; 6.输出信息1Android程序员，使用Java编程语言，写了三行代码，竟然没用bug。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.xuqinmin.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"android","slug":"android","permalink":"https://blog.xuqinmin.com/tags/android/"},{"name":"java","slug":"java","permalink":"https://blog.xuqinmin.com/tags/java/"}]},{"title":"设计模式-建造者模式(简化-链式)","slug":"设计模式-建造者模式-简易模式","date":"2020-05-20T06:46:57.000Z","updated":"2020-05-20T08:13:42.097Z","comments":true,"path":"2020/05/20/设计模式-建造者模式-简易模式/","link":"","permalink":"https://blog.xuqinmin.com/2020/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-%E7%AE%80%E6%98%93%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"最近在学习设计模式，之前断断续续的看过好多，自己也没有专门的练习和深入了解过，一直感觉对应设计模式相关的东西还是处于懵懂状态，这次下定决心好好的学习一下，所以做一个笔记用来督促自己。 资料收集与以下网站，如有冒犯，烦请告知https://www.runoob.com/design-pattern/builder-pattern.html 定义The intent of the Builder design pattern is to separate the construction of a complex object from its representation. By doing so the same construction process can create different representations.将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示 简单说明1.当一个类的构建过于复杂的时候，就可以考虑builder模式了。 上手试一下，还是用coder的例子吧 1.程序员基类1234567891011121314151617public class Coder &#123; private String name;//名称 private String language;//使用的语言 private String coding;//编程能力 private String writeBug;//bug生成能力 public Coder(Builder builder) &#123; this.name = builder.getName(); this.language = builder.getLanguage(); this.coding = builder.getCoding(); this.writeBug = builder.getWriteBug(); &#125; public void draw() &#123; System.out.printf(\"%s程序员，使用%s编程语言，%s，%s。\", name, language, coding, writeBug); &#125;&#125; 2.builder 类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Builder &#123; private String name; private String language; private String coding; private String writeBug; public Builder setName(String name) &#123; this.name = name; return this; &#125; public Builder setLanguage(String language) &#123; this.language = language; return this; &#125; public Builder setCoding(String coding) &#123; this.coding = coding; return this; &#125; public Builder setWriteBug(String writeBug) &#123; this.writeBug = writeBug; return this; &#125; public String getName() &#123; return name; &#125; public String getLanguage() &#123; return language; &#125; public String getCoding() &#123; return coding; &#125; public String getWriteBug() &#123; return writeBug; &#125; public Coder build() &#123; return new Coder(this); &#125;&#125; 3.使用一下1234567891011public class Test &#123; public static void main(String[] args) &#123; Coder coder = new Builder() .setCoding(\"写了一行代码\") .setLanguage(\"Java\") .setName(\"Android\") .setWriteBug(\"没有bug\") .build(); coder.draw(); &#125;&#125; 4.输出信息1Android程序员，使用Java编程语言，写了一行代码，没有bug。 换一个写法 1.coder1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Coder &#123; private String name; private String language; private String coding; private String writeBug; public Coder(Builder builder) &#123; this.name = builder.name; this.language = builder.language; this.coding = builder.coding; this.writeBug = builder.writeBug; &#125; public void draw() &#123; System.out.printf(\"%s程序员，使用%s编程语言，%s，%s。\", name, language, coding, writeBug); &#125; public static class Builder &#123; private String name; private String language; private String coding; private String writeBug; public Builder setName(String name) &#123; this.name = name; return this; &#125; public Builder setLanguage(String language) &#123; this.language = language; return this; &#125; public Builder setCoding(String coding) &#123; this.coding = coding; return this; &#125; public Builder setWriteBug(String writeBug) &#123; this.writeBug = writeBug; return this; &#125; public Coder build() &#123; return new Coder(this); &#125; &#125;&#125; 2.使用方式1234567891011public class Test &#123; public static void main(String[] args) &#123; Coder coder = new Coder.Builder() .setCoding(\"写了一行代码\") .setLanguage(\"Java\") .setName(\"Android\") .setWriteBug(\"没有bug\") .build(); coder.draw(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.xuqinmin.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"android","slug":"android","permalink":"https://blog.xuqinmin.com/tags/android/"},{"name":"java","slug":"java","permalink":"https://blog.xuqinmin.com/tags/java/"}]},{"title":"Android开发整理---Jetpack学习记录001","slug":"Android开发整理---Jetpack学习记录001","date":"2020-05-20T05:54:35.000Z","updated":"2020-05-20T05:58:23.399Z","comments":true,"path":"2020/05/20/Android开发整理---Jetpack学习记录001/","link":"","permalink":"https://blog.xuqinmin.com/2020/05/20/Android%E5%BC%80%E5%8F%91%E6%95%B4%E7%90%86---Jetpack%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95001/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://blog.xuqinmin.com/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://blog.xuqinmin.com/tags/android/"},{"name":"kotlin","slug":"kotlin","permalink":"https://blog.xuqinmin.com/tags/kotlin/"}]},{"title":"使用Django 做服务端开发的一次尝试-3","slug":"django 做服务端的练习-003","date":"2020-04-20T03:30:01.000Z","updated":"2020-04-20T03:30:46.483Z","comments":true,"path":"2020/04/20/django 做服务端的练习-003/","link":"","permalink":"https://blog.xuqinmin.com/2020/04/20/django%20%E5%81%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E7%BB%83%E4%B9%A0-003/","excerpt":"","text":"","categories":[{"name":"python","slug":"python","permalink":"https://blog.xuqinmin.com/categories/python/"},{"name":"django","slug":"python/django","permalink":"https://blog.xuqinmin.com/categories/python/django/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.xuqinmin.com/tags/python/"},{"name":"django","slug":"django","permalink":"https://blog.xuqinmin.com/tags/django/"},{"name":"restframework","slug":"restframework","permalink":"https://blog.xuqinmin.com/tags/restframework/"}]},{"title":"使用Django 做服务端开发的一次尝试-2","slug":"django 做服务端的练习-002","date":"2020-04-17T10:06:46.000Z","updated":"2020-05-18T06:18:05.705Z","comments":true,"path":"2020/04/17/django 做服务端的练习-002/","link":"","permalink":"https://blog.xuqinmin.com/2020/04/17/django%20%E5%81%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E7%BB%83%E4%B9%A0-002/","excerpt":"","text":"之前完成了一个django项目的新建工作，这次就做一些初始化的东西吧 1.使用postgresql数据库数据库用户、密码、库 这些东西，先准备好使用 pip install psycopg2 命令安装 psycopg2 作为数据库驱动，可能会遇到问题，我是直接安装了个vs2019 解决的，粗暴而简单修改settings.py文件(自己本地玩的，用户名密码就不隐藏了)123456789101112DATABASES = &#123; 'default': &#123; # 'ENGINE': 'django.db.backends.sqlite3', # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'django-rest', # 数据库名字 'USER': 'django', # 用户名 \"PASSWORD\": '123456', # 自己的密码 \"HOST\": '127.0.0.1', 'PORT': 5432, &#125;&#125;直接迁移数据库：python manage.py migrate数据库迁移完成，我习惯直接开启admin，python manage.py createsuperuser1234567891011121314(venv) E:\\PythonProjects\\djanfo_rest&gt;python manage.py createsuperuserUsername (leave blank to use 'xuqin'): xuqmError: That username is already taken.Username (leave blank to use 'xuqin'): adminEmail address: 123456Error: Enter a valid email address.Email address: xuqinmin12@sina.comPassword:Password (again):This password is too short. It must contain at least 8 characters.This password is too common.This password is entirely numeric.Bypass password validation and create user anyway? [y/N]: ySuperuser created successfully.使用的是一个旧的数据库，所以其实已经创建过超级用户了理论上现在可以看到管理页面了，http://127.0.0.1:8000/admin输入刚才创建的超级用户的用户名密码，完成登录就是长的这样子。现有有个问题，我这个学渣，看不懂英文。改！修改settings.py文件123LANGUAGE_CODE = 'zh-Hans'TIME_ZONE = 'Asia/Harbin'结果就好看多了么下班了~","categories":[{"name":"python","slug":"python","permalink":"https://blog.xuqinmin.com/categories/python/"},{"name":"django","slug":"python/django","permalink":"https://blog.xuqinmin.com/categories/python/django/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.xuqinmin.com/tags/python/"},{"name":"django","slug":"django","permalink":"https://blog.xuqinmin.com/tags/django/"},{"name":"restframework","slug":"restframework","permalink":"https://blog.xuqinmin.com/tags/restframework/"}]},{"title":"使用Django 做服务端开发的一次尝试-1","slug":"django 做服务端的练习","date":"2020-04-17T06:38:24.000Z","updated":"2020-05-18T06:17:41.343Z","comments":true,"path":"2020/04/17/django 做服务端的练习/","link":"","permalink":"https://blog.xuqinmin.com/2020/04/17/django%20%E5%81%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E7%BB%83%E4%B9%A0/","excerpt":"","text":"最近在学习设计模式，之前断断续续的看过好多，自己也没有专门的练习和深入了解过，一直感觉对应设计模式相关的东西还是处于懵懂状态，这次下定决心好好的学习一下，所以做一个笔记用来督促自己。前段时间，想要整理一下现有的Android技术，写一个可以用的快速开发框架，然而，咸鱼依然还是咸鱼。使用mvvm模式，写了一部分。不会放出来的，那么羞耻的东西。重点是，想要调用接口做测试的时候，突然想起来当年玩过几天Django，接着就想，是不是可以用django写一个测试用的服务呢？写一个试试吧。 走一步看一步吧，走到哪是哪才是咸鱼的本命 1.新建一个项目，这里我用的是 PyCharm做的开发。写到这里，突然想起来需要截图，然后想了下图片需要上传到服务器，然后想要了解下有哪些可以用的服务器，等我回来。想了想，自己有个闲置的阿里云服务器，就用它吧写了个脚本，使用 python -m SimpleHTTPServer 启动一个文件服务我的项目都是这么创建的，感觉比较方便环境用的是anaconda 的python3.7，我本地的是3.8版本，直接使用的时候，配置postgresql的时候会出问题，没找到为啥，换了一个就好了等了一会，该转的圈转完了，新建项目的工作完成了。目录结构启动一下看看效果,看看开心的小火箭。","categories":[{"name":"python","slug":"python","permalink":"https://blog.xuqinmin.com/categories/python/"},{"name":"django","slug":"python/django","permalink":"https://blog.xuqinmin.com/categories/python/django/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.xuqinmin.com/tags/python/"},{"name":"django","slug":"django","permalink":"https://blog.xuqinmin.com/tags/django/"},{"name":"restframework","slug":"restframework","permalink":"https://blog.xuqinmin.com/tags/restframework/"}]},{"title":"设计模式-抽象工厂模式","slug":"设计模式-抽象工厂模式","date":"2020-04-03T05:32:01.000Z","updated":"2020-05-20T06:52:13.374Z","comments":true,"path":"2020/04/03/设计模式-抽象工厂模式/","link":"","permalink":"https://blog.xuqinmin.com/2020/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"最近在学习设计模式，之前断断续续的看过好多，自己也没有专门的练习和深入了解过，一直感觉对应设计模式相关的东西还是处于懵懂状态，这次下定决心好好的学习一下，所以做一个笔记用来督促自己。 资料收集与以下网站，如有冒犯，烦请告知https://www.runoob.com/design-pattern/design-pattern-tutorial.htmlhttps://www.cnblogs.com/XiOrang/p/9410851.html 简单说明抽象工厂模式，主要是围绕着一个超级工厂创建其它工厂的模式。这个设计模式，将产品归类为多个产品族，每个单品族单独管理产品。抽象工厂模式有多个产品。编不下去了！！！我承认我就是个菜狗 简单理解需要定义多个产品接口，包含各产品的共通的东西。各产品实现上面的接口定义工厂类用于生产定义超级工厂类，用于管理上面的小工厂之前工厂模式的时候，用了一个coder的例子。这里我把coder的技能单独比做产品来使用，不是很合适，勉强看一下吧。 1.定义产品接口1234//可能会的技能public class Coding&#123; void run();&#125;1234//必会的技能public class WriteBugs&#123; void run();&#125; 2.实现产品接口123456public class AndroidCoding implements Coding&#123; @Override public void run()&#123; System.out.pringln(\"Android程序员写了一段代码\"); &#125;&#125;123456public class IosCoding implements Coding&#123; @Override public void run()&#123; System.out.pringln(\"Ios程序员没写代码\"); &#125;&#125;123456public class AndroidBugs implements WriteBugs&#123; @Override public void run()&#123; System.out.pringln(\"Android程序员说没有bug的日子好寂寞啊！！！\"); &#125;&#125;123456public class IosBugs implements WriteBugs&#123; @Override public void run()&#123; System.out.pringln(\"Ios程序员说这些bug哪来的啊！！！\"); &#125;&#125; 3.创建超级工厂抽象类1234public abstract class AbstractFactory&#123; public abstract Coding getCoding(); public abstract WriteBugs getBugs();&#125; 4.创建小工厂，扩展超级工厂12345678910public class AndroidFactory extends AbstractFactory&#123; @Override public Coding getCoding()&#123; return new AndroidCoding(); &#125; @Override public WriteBugs getBugs()&#123; return new AndroidBugs(); &#125;&#125;12345678910public class IosFactory extends AbstractFactory&#123; @Override public Coding getCoding()&#123; return new IosCoding(); &#125; @Override public WriteBugs getBugs()&#123; return new IosBugs(); &#125;&#125; 5.创建一个工厂生成器12345678910public class FactoryProducer&#123; public static AbstractFactory getFactory(String type)&#123; if(\"ANDROID\".equalsIgnoreCase(type))&#123; return new AndroidFactory(); &#125;else if(\"IOS\".equalsIgnoreCase(type))&#123; return new IosFactory(); &#125; return null; &#125;&#125; 6.使用过程12345678910111213141516public class Test&#123; public static void main(Strign[] args)&#123; AbstractFactory android = FactoryProducer.getFactory(\"Android\"); Coding androidCoding = android.getCoding(); WriteBugs androidBugs = android.getBugs(); androidCoding.run(); androidBugs.run(); AbstractFactory ios = FactoryProducer.getFactory(\"IOS\"); Coding iosCoding = ios.getCoding(); WriteBugs iosBugs = ios.getBugs(); iosCoding.run(); iosBugs.run(); &#125;&#125;感觉菜鸟教程的抽象工厂模式有点问题，不知道是不是我的理解有错误。个人觉得抽象工厂里面的小工厂应该是包含多个不同类型产品的工厂菜鸟的教程是包含多个同一类型的产品","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.xuqinmin.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"android","slug":"android","permalink":"https://blog.xuqinmin.com/tags/android/"},{"name":"java","slug":"java","permalink":"https://blog.xuqinmin.com/tags/java/"}]},{"title":"设计模式-工厂模式","slug":"设计模式-工厂模式","date":"2020-04-03T03:38:24.000Z","updated":"2020-04-03T04:05:14.717Z","comments":true,"path":"2020/04/03/设计模式-工厂模式/","link":"","permalink":"https://blog.xuqinmin.com/2020/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"最近在学习设计模式，之前断断续续的看过好多，自己也没有专门的练习和深入了解过，一直感觉对应设计模式相关的东西还是处于懵懂状态，这次下定决心好好的学习一下，所以做一个笔记用来督促自己。 资料收集与以下网站，如有冒犯，烦请告知https://www.runoob.com/design-pattern/design-pattern-tutorial.html 简单说明工厂模式属于创建型设计模式的一种。使用这个模式，我们不需要知道实例是怎么创建的，完全由工厂根据我们的需求来搞。每次增加新实例的时候，都需要添加一个具体类和实现工厂，增加了系统的复杂度，同时也增加了系统具体类的依赖。编不下去了！！！我承认我就是个菜狗 简单理解需要定义一个接口，包含各产品的共通的东西。各产品实现上面的接口定义工厂类用于生产我需要一个小伙伴陪我一起coding，奈何现实不理我，没办法，自己生产一个？？？ 1.定义一个接口1234public interface Coder&#123; //会coding就够了，还要啥自行车 void coding();&#125; 2.来一个Android的coder吧123456public class Android implements Coder&#123; @Override public void coding()&#123; System.out.println(\"Android开发，在线接客！\") &#125;&#125; 3.其实IOS开发也是可以的123456public class Ios implements Coder&#123; @Override public void coding()&#123; System.out.println(\"没有bug的日子，好寂寞！！！\") &#125;&#125; 4.需要一个学校？培训机构来生产他们啊(Factory)123456789101112public class CoderFactory&#123; public Coder getCoder(String type)&#123; if(null == type) return null; if(\"ANDROID\".equalsIgnoreCase(type))&#123; return new Android(); &#125;else if(\"IOS\".equalsIgnoreCase(type))&#123; return new Ios(); &#125; return null; &#125;&#125; 5.神说要有光~~~123456789public class TestCoder&#123; public static void main(String[] args)&#123; CoderFactory factory = new CoderFactory(); Android android = factory.getCoder(\"Android\"); Ios ios = factory.getCoder(\"IOS\"); android.coding(); ios.coding(); &#125;&#125;梦醒了，除了嘴角有点湿，啥也没搞到。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.xuqinmin.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"android","slug":"android","permalink":"https://blog.xuqinmin.com/tags/android/"},{"name":"java","slug":"java","permalink":"https://blog.xuqinmin.com/tags/java/"}]},{"title":"设计模式-单例模式","slug":"设计模式-单例模式","date":"2020-04-03T02:12:48.000Z","updated":"2020-04-03T03:27:30.163Z","comments":true,"path":"2020/04/03/设计模式-单例模式/","link":"","permalink":"https://blog.xuqinmin.com/2020/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"最近在学习设计模式，之前断断续续的看过好多，自己也没有专门的练习和深入了解过，一直感觉对应设计模式相关的东西还是处于懵懂状态，这次下定决心好好的学习一下，所以做一个笔记用来督促自己。 资料收集与以下网站，如有冒犯，烦请告知https://www.cnblogs.com/garryfu/p/7976546.htmlhttp://c.biancheng.net/design_pattern/https://www.runoob.com/design-pattern/design-pattern-tutorial.html 简单说明单例模式可以维持系统内某个类只有一个实例。在系统中，日志对象、对话框、打印机驱动等通常的会设计成单例模式。单例模式主要用来保持状态的统一，避免不同请求同时调用时，会造成状态混乱的情况。编不下去了！！！我承认我就是个菜狗 简单理解类的构造器私有化内部实例化外部全局访问 静态常量实现 饿汉式123456789101112131415161718192021public class Singleton &#123; //私有化构造函数 private Singleton() &#123; &#125; //静态常量 private static final Singleton instance = new Singleton(); //外部访问接口 public static Singleton getInstance() &#123; return instance; &#125; //提供一个外部访问方法，用来测试 public void print() &#123; System.out.println(\"创建成功\"); &#125;&#125;class a &#123; public static void main(String[] args) &#123; Singleton.getInstance().print();//测试 &#125;&#125; 静态代码块实现 - 饿汉式12345678910111213141516public class Singleton&#123; //私有化构造函数 private Singletonton()&#123; &#125; //静态代码块实现 private static Singleton instance; static&#123; instance = new Singleton(); &#125; //提供一个外部访问的方法 public static Singleton getInstance()&#123; return instance; &#125; &#125; 模式特点饿汉式单例，在类加载的时候就已经创建好了一个静态对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程 线程不安全的 - 懒汉式1234567891011public class Singleton&#123; private static Singleton instance; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; if(null == instance) instance = new Singleton(); return instance; &#125;&#125; 线程安全的 - 懒汉式1234567891011public class Singleton&#123; private static Singleton instance; private Singleton()&#123; &#125; public static synchronized Singleton getInstance()&#123; if(null == instance) instance = new Singleton(); return instance; &#125;&#125; 模式特点懒汉式单例模式，使用了延迟加载的方式，只有在调用getInstance()方法时才会进行实例化第一种模式虽然可以做到延时加载，但是在多线程的使用场景中容易出现多实例的情况第二种模式添加了synchronized同步锁，使得该方法变成了线程安全的方式，但是多数情况下是不需要同步的，所以该模式运行效率很低。 双重校验锁模式1234567891011121314151617public class Singleton &#123; private Singleton()&#123; &#125; private static Singleton instance; public static Singleton getInstance()&#123; if(null == instance)&#123; synchronized(Singleton.class)&#123; if(null == instance)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; &#125; 模式特点延迟加载第一次判断instance为空的时候，会进入同步锁，进入同步锁的线程根据再次判断的情况，实例化Singleton,第二次访问的时候，instance不为空，则不进入同步锁，保证了执行效率。 静态内部类模式1234567891011public class Singleton&#123; private Singleton()&#123; &#125; private static class SingletonHolder&#123; private static Singleton instance = new Singleton(); &#125; public static Singleton getInstance()&#123; return SingletonHolder.instance; &#125;&#125; 模式特点多线程并发下，线程是安全的但是遇到序列号对象时，默认的方式运行得到的结果就是多例的。 枚举模式12345678910111213public enum Singleton&#123; INSTANCE; private String test = \"singleton\"; public void print()&#123; System.out.println(a); &#125;&#125;//测试一下public test&#123; public static void main(String[] args)&#123; Singleton.INSTANCE.print(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.xuqinmin.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"android","slug":"android","permalink":"https://blog.xuqinmin.com/tags/android/"},{"name":"java","slug":"java","permalink":"https://blog.xuqinmin.com/tags/java/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://blog.xuqinmin.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"设计模式","slug":"设计模式","permalink":"https://blog.xuqinmin.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Android","slug":"Android","permalink":"https://blog.xuqinmin.com/categories/Android/"},{"name":"python","slug":"python","permalink":"https://blog.xuqinmin.com/categories/python/"},{"name":"django","slug":"python/django","permalink":"https://blog.xuqinmin.com/categories/python/django/"}],"tags":[{"name":"css","slug":"css","permalink":"https://blog.xuqinmin.com/tags/css/"},{"name":"android","slug":"android","permalink":"https://blog.xuqinmin.com/tags/android/"},{"name":"java","slug":"java","permalink":"https://blog.xuqinmin.com/tags/java/"},{"name":"kotlin","slug":"kotlin","permalink":"https://blog.xuqinmin.com/tags/kotlin/"},{"name":"python","slug":"python","permalink":"https://blog.xuqinmin.com/tags/python/"},{"name":"django","slug":"django","permalink":"https://blog.xuqinmin.com/tags/django/"},{"name":"restframework","slug":"restframework","permalink":"https://blog.xuqinmin.com/tags/restframework/"}]}