{"meta":{"title":"你过来啊！","subtitle":"性感Android开发，在线挨打","description":"每过段时间，就要踌躇满志一波，但是只能硬三分钟。","author":"Xuqm","url":"https://xuqm.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-04-02T09:55:00.649Z","updated":"2020-04-02T07:25:54.074Z","comments":false,"path":"categories/index.html","permalink":"https://xuqm.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-04-02T09:54:41.258Z","updated":"2020-04-02T07:25:54.073Z","comments":false,"path":"about/index.html","permalink":"https://xuqm.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"Repositories","date":"2020-04-02T08:35:47.091Z","updated":"2020-04-02T07:25:54.074Z","comments":false,"path":"repository/index.html","permalink":"https://xuqm.github.io/repository/index.html","excerpt":"","text":""},{"title":"archives","date":"2020-04-02T07:37:15.000Z","updated":"2020-04-02T09:35:55.453Z","comments":false,"path":"archives/index.html","permalink":"https://xuqm.github.io/archives/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-04-02T09:55:07.904Z","updated":"2020-04-02T07:25:54.074Z","comments":true,"path":"links/index.html","permalink":"https://xuqm.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-02T09:55:27.032Z","updated":"2020-04-02T07:25:54.074Z","comments":false,"path":"tags/index.html","permalink":"https://xuqm.github.io/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2020-04-02T09:54:20.283Z","updated":"2020-04-02T07:25:54.073Z","comments":false,"path":"/404.html","permalink":"https://xuqm.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2020-04-02T09:54:55.864Z","updated":"2020-04-02T07:25:54.073Z","comments":false,"path":"books/index.html","permalink":"https://xuqm.github.io/books/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式-单例模式","slug":"设计模式-单例模式","date":"2020-04-03T02:12:48.000Z","updated":"2020-04-03T03:25:35.929Z","comments":true,"path":"2020/04/03/设计模式-单例模式/","link":"","permalink":"https://xuqm.github.io/2020/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"最近在学习设计模式，之前断断续续的看过好多，自己也没有专门的练习和深入了解过，一直感觉对应设计模式相关的东西还是处于懵懂状态，这次下定决心好好的学习一下，所以做一个笔记用来督促自己。 资料手机与一下网站，如有冒犯，烦请告知https://www.cnblogs.com/garryfu/p/7976546.htmlhttp://c.biancheng.net/design_pattern/https://www.runoob.com/design-pattern/design-pattern-tutorial.html 简单说明单例模式可以维持系统内某个类只有一个实例。在系统中，日志对象、对话框、打印机驱动等通常的会设计成单例模式。单例模式主要用来保持状态的统一，避免不同请求同时调用时，会造成状态混乱的情况。编不下去了！！！我承认我就是个菜狗 简单理解类的构造器私有化内部实例化外部全局访问 静态常量实现 饿汉式123456789101112131415161718192021public class Singleton &#123; //私有化构造函数 private Singleton() &#123; &#125; //静态常量 private static final Singleton instance = new Singleton(); //外部访问接口 public static Singleton getInstance() &#123; return instance; &#125; //提供一个外部访问方法，用来测试 public void print() &#123; System.out.println(\"创建成功\"); &#125;&#125;class a &#123; public static void main(String[] args) &#123; Singleton.getInstance().print();//测试 &#125;&#125; 静态代码块实现 - 饿汉式12345678910111213141516public class Singleton&#123; //私有化构造函数 private Singletonton()&#123; &#125; //静态代码块实现 private static Singleton instance; static&#123; instance = new Singleton(); &#125; //提供一个外部访问的方法 public static Singleton getInstance()&#123; return instance; &#125; &#125; 模式特点饿汉式单例，在类加载的时候就已经创建好了一个静态对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程 线程不安全的 - 懒汉式1234567891011public class Singleton&#123; private static Singleton instance; private Singleton()&#123; &#125; public static Singleton getInstance()&#123; if(null == instance) instance = new Singleton(); return instance; &#125;&#125; 线程安全的 - 懒汉式1234567891011public class Singleton&#123; private static Singleton instance; private Singleton()&#123; &#125; public static synchronized Singleton getInstance()&#123; if(null == instance) instance = new Singleton(); return instance; &#125;&#125; 模式特点懒汉式单例模式，使用了延迟加载的方式，只有在调用getInstance()方法时才会进行实例化第一种模式虽然可以做到延时加载，但是在多线程的使用场景中容易出现多实例的情况第二种模式添加了synchronized同步锁，使得该方法变成了线程安全的方式，但是多数情况下是不需要同步的，所以该模式运行效率很低。 双重校验锁模式1234567891011121314151617public class Singleton &#123; private Singleton()&#123; &#125; private static Singleton instance; public static Singleton getInstance()&#123; if(null == instance)&#123; synchronized(Singleton.class)&#123; if(null == instance)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; &#125; 模式特点延迟加载第一次判断instance为空的时候，会进入同步锁，进入同步锁的线程根据再次判断的情况，实例化Singleton,第二次访问的时候，instance不为空，则不进入同步锁，保证了执行效率。 静态内部类模式1234567891011public class Singleton&#123; private Singleton()&#123; &#125; private static class SingletonHolder&#123; private static Singleton instance = new Singleton(); &#125; public static Singleton getInstance()&#123; return SingletonHolder.instance; &#125;&#125; 模式特点多线程并发下，线程是安全的但是遇到序列号对象时，默认的方式运行得到的结果就是多例的。 枚举模式12345678910111213public enum Singleton&#123; INSTANCE; private String test = \"singleton\"; public void print()&#123; System.out.println(a); &#125;&#125;//测试一下public test&#123; public static void main(String[] args)&#123; Singleton.INSTANCE.print(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xuqm.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"android","slug":"android","permalink":"https://xuqm.github.io/tags/android/"},{"name":"java","slug":"java","permalink":"https://xuqm.github.io/tags/java/"}]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xuqm.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"android","slug":"android","permalink":"https://xuqm.github.io/tags/android/"},{"name":"java","slug":"java","permalink":"https://xuqm.github.io/tags/java/"}]}